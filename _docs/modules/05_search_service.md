# SearchService 模块设计

> 搜索功能：全文搜索、语义搜索、向量索引

---

## 一、模块职责

| 子功能 | 说明 |
|--------|------|
| **全文搜索** | 关键词匹配，快速精确查找 |
| **语义搜索** | 基于向量的相似度搜索 |
| **索引管理** | 创建、更新、重建索引 |
| **混合搜索** | 结合全文和语义的综合搜索 |

---

## 二、核心工作流

### 2.1 搜索请求处理

```
用户输入: "林逸和谁有仇"
    │
    ▼
┌─────────────────────────────────────────┐
│ 1. 查询预处理                            │
│    - 分词: ["林逸", "和", "谁", "有仇"] │
│    - 提取实体: ["林逸"]                 │
│    - 识别意图: 关系查询                 │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 2. 并行执行两种搜索                      │
│                                         │
│    ┌─────────────┐  ┌─────────────────┐ │
│    │ 全文搜索    │  │ 语义搜索        │ │
│    │ FTS5 MATCH  │  │ Vector KNN      │ │
│    └──────┬──────┘  └────────┬────────┘ │
│           │                  │          │
│           └────────┬─────────┘          │
│                    ▼                    │
│    ┌────────────────────────────────┐   │
│    │ 结果融合 (Reciprocal Rank      │   │
│    │         Fusion)                │   │
│    └────────────────────────────────┘   │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 3. 结果排序与返回                        │
│    - 按融合分数排序                     │
│    - 生成高亮片段                       │
│    - 返回 Top N 结果                    │
└─────────────────────────────────────────┘
```

### 2.2 全文搜索 (FTS5)

```
索引结构:
┌─────────────────────────────────────────┐
│ CREATE VIRTUAL TABLE search_fts USING   │
│ fts5(                                   │
│   entity_type,  -- 类型: character/...  │
│   entity_id,    -- 实体ID               │
│   title,        -- 标题/名称            │
│   content,      -- 全文内容             │
│   tokenize='unicode61'                  │
│ );                                      │
└─────────────────────────────────────────┘

查询示例:
┌─────────────────────────────────────────┐
│ SELECT                                  │
│   entity_type,                          │
│   entity_id,                            │
│   snippet(search_fts, 3, '<b>', '</b>', │
│           '...', 32) as highlight,      │
│   bm25(search_fts) as score             │
│ FROM search_fts                         │
│ WHERE search_fts MATCH '林逸 OR 仇'     │
│ ORDER BY score                          │
│ LIMIT 20;                               │
└─────────────────────────────────────────┘

优点:
  ✓ 精确匹配，不遗漏
  ✓ 速度快 (毫秒级)
  ✓ 支持 AND/OR/NOT

缺点:
  ✗ 不理解语义
  ✗ 同义词不匹配
```

### 2.3 语义搜索 (Vector)

```
索引结构:
┌─────────────────────────────────────────┐
│ embeddings 表:                          │
│   entity_type TEXT,                     │
│   entity_id TEXT,                       │
│   chunk_id INTEGER,  -- 分块索引        │
│   content TEXT,      -- 原文            │
│   embedding BLOB     -- 向量 (1536维)   │
│                                         │
│ + sqlite-vss 扩展的向量索引             │
└─────────────────────────────────────────┘

查询流程:
    │
    ▼
┌─────────────────────────────────────────┐
│ 1. 查询文本 → Embedding                 │
│    query_vec = embed("林逸和谁有仇")   │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 2. KNN 搜索                             │
│    SELECT * FROM embeddings             │
│    WHERE vss_search(embedding,          │
│                     query_vec,          │
│                     20)  -- Top 20      │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 3. 返回相似度 + 原文                    │
│    结果包含:                            │
│    - entity_type, entity_id             │
│    - content (原文片段)                 │
│    - similarity (0-1)                   │
└─────────────────────────────────────────┘

优点:
  ✓ 理解语义，"仇人"也能找到
  ✓ 支持问答式查询

缺点:
  ✗ 可能有误匹配
  ✗ 速度较慢 (100ms+)
  ✗ 依赖 Embedding 质量
```

### 2.4 混合搜索融合算法

```
Reciprocal Rank Fusion (RRF):
┌─────────────────────────────────────────┐
│                                         │
│   score(doc) = Σ  1 / (k + rank_i(doc)) │
│               i∈methods                 │
│                                         │
│   k = 60 (常数，平衡权重)              │
│                                         │
│   示例:                                 │
│     文档A: FTS排名1, Vector排名3        │
│     score = 1/(60+1) + 1/(60+3)        │
│           = 0.0164 + 0.0159            │
│           = 0.0323                      │
│                                         │
│     文档B: FTS排名5, Vector排名1        │
│     score = 1/(60+5) + 1/(60+1)        │
│           = 0.0154 + 0.0164            │
│           = 0.0318                      │
│                                         │
│   结果: A > B (综合更优)                │
└─────────────────────────────────────────┘

权重调整:
  - 精确搜索场景: FTS 权重 x 1.5
  - 探索性搜索场景: Vector 权重 x 1.5
```

---

## 三、索引更新策略

### 3.1 实时更新

```
触发: 实体创建/更新事件
    │
    ▼
┌─────────────────────────────────────────┐
│ EventBus 监听:                          │
│   CHARACTER_CREATED → updateIndex()     │
│   CHARACTER_UPDATED → updateIndex()     │
│   CHAPTER_SAVED     → updateIndex()     │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 更新步骤:                               │
│                                         │
│ 1. FTS 更新 (同步):                     │
│    DELETE FROM search_fts WHERE ...     │
│    INSERT INTO search_fts ...           │
│                                         │
│ 2. Embedding 更新 (异步):               │
│    - 加入更新队列                       │
│    - 后台批量处理 (每 5 秒)            │
└─────────────────────────────────────────┘
```

### 3.2 批量重建

```
场景:
  - 首次启动
  - 数据损坏恢复
  - Embedding 模型升级

流程:
    │
    ▼
┌─────────────────────────────────────────┐
│ 1. 清空现有索引                          │
│    DROP TABLE search_fts;               │
│    DELETE FROM embeddings;              │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 2. 遍历所有实体                          │
│    - characters                         │
│    - world (locations, factions, ...)   │
│    - chapters                           │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 3. 分批处理                              │
│    - FTS: 批量 INSERT (100条/批)        │
│    - Embedding: 并行调用 API (5条/批)   │
│    - 显示进度条                         │
└─────────────────────────────────────────┘
    │
    ▼
┌─────────────────────────────────────────┐
│ 4. 完成通知                              │
│    INDEX_REBUILD_COMPLETED              │
└─────────────────────────────────────────┘
```

---

## 四、内容分块策略

```
为什么要分块？
  - 长文本超出 Embedding 模型限制
  - 分块后搜索更精准
  - 便于定位具体位置

分块规则:
┌─────────────────────────────────────────┐
│ 角色档案:                               │
│   - 基本信息 → 1 块                    │
│   - 每层动机 → 各 1 块                 │
│   - 关系列表 → 1 块                    │
│                                         │
│ 世界设定:                               │
│   - 按段落分块                          │
│   - 每块 300-500 字                    │
│                                         │
│ 章节内容:                               │
│   - 按段落分块                          │
│   - 保留段落上下文 (前后各 1 段)       │
│   - 每块 500-800 字                    │
└─────────────────────────────────────────┘

示例:
  原文 3000 字章节 → 5 个块
  每块独立 Embedding
  搜索时返回最相关的块
```

---

## 五、与其他模块的交互

| 交互模块 | 方向 | 场景 |
|----------|------|------|
| **AIService** | → | AI Context 构建时调用语义搜索 |
| **StoryBibleService** | ← | 实体变更时更新索引 |
| **WritingService** | ← | 章节保存时更新索引 |
| **EventBus** | ← | 监听变更事件 |

---

## 六、关键设计决策

### 6.1 为什么选择 sqlite-vss

```
选项对比:
┌─────────────────────────────────────────┐
│ sqlite-vss:                             │
│   ✓ 纯本地，无外部依赖                 │
│   ✓ 与 SQLite 无缝集成                 │
│   ✓ 足够应对单项目规模 (< 10万向量)   │
│   ✗ 性能不如专业向量数据库             │
│                                         │
│ Qdrant/Milvus:                          │
│   ✓ 性能优秀                           │
│   ✗ 需要额外服务                       │
│   ✗ 增加部署复杂度                     │
│                                         │
│ 选择: sqlite-vss                        │
│ 理由: 本地优先原则，单机性能足够       │
└─────────────────────────────────────────┘
```

### 6.2 Embedding 缓存策略

```
问题: 频繁调用 Embedding API 成本高

解决:
┌─────────────────────────────────────────┐
│ 1. 内容哈希检查                          │
│    content_hash = md5(content)          │
│    if hash unchanged → 跳过 Embedding   │
│                                         │
│ 2. 本地 Embedding 模型 (可选)           │
│    - 使用 sentence-transformers        │
│    - 质量稍差但免费                     │
│    - 作为 fallback                      │
└─────────────────────────────────────────┘
```

---

## 七、错误处理

| 错误场景 | 处理 |
|----------|------|
| Embedding API 失败 | 标记 pending，稍后重试；搜索时只用 FTS |
| 索引损坏 | 自动触发重建 |
| 搜索超时 | 返回部分结果 + 提示 |

---

*Review 重点: 混合搜索融合算法、分块策略、sqlite-vss选型*
