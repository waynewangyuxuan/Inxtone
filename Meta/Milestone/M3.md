# Milestone 3: Writing Workspace

- **Status**: Draft
- **Target Date**: 2026-04-11
- **Owner**: Wayne
- **Duration**: 3 weeks
- **Dependencies**: M2 (Story Bible Core)

## Goal

Implement the **Writing Workspace** - the core writing experience with AI collaboration. Users can write chapters with AI assistance while the system maintains context from the Story Bible. The core showcase is **AI that knows your story** — not just text generation, but structure-aware, plot-aware content creation.

## Success Criteria

After M3, users should be able to:

```
✓ Create and edit chapters in a distraction-free editor
✓ Use AI (Gemini 2.5 Pro) to continue writing or generate dialogue
✓ See relevant Story Bible context while writing (auto-assembled)
✓ Track version history and rollback changes
✓ Manage plot structure via Arc Outliner and Foreshadowing Tracker
```

## Scope

### In Scope

1. **Chapter Editor (P0)**
   - Markdown editor (`@uiw/react-md-editor`, lightweight ~4.6kB)
   - Manual save (Ctrl+S / Save button)
   - Chapter navigation (prev/next)
   - Word count display

2. **AI Integration (P0)**
   - Gemini 2.5 Pro via `@google/genai` SDK
   - **Context Builder**: deterministic FK-based context assembly (see Technical Notes)
   - Continuation, dialogue generation, scene description
   - SSE streaming responses
   - **Sidebar Preview + Accept** interaction model

3. **Writing Service Implementation**
   - Chapter CRUD + Volume CRUD
   - Version history (manual version, auto-version before AI generation)
   - Rollback functionality
   - FK cleanup: 删除实体时自动清理章节引用

4. **Plot System (P0)**
   - Arc outliner (hierarchical view, core value differentiator)
   - Foreshadowing ledger (plant → hint → resolve lifecycle)
   - Hook tracker

5. **UI Components**
   - Three-panel layout: Navigation + Editor + AI Sidebar
   - Chapter editor page with auto-save indicator
   - AI sidebar: context preview, quick actions, streaming response display
   - Story Bible quick-access panel (left panel)
   - Plot Outliner page (Arc → Chapter tree)
   - Foreshadowing Tracker view

### Out of Scope

- Writing Goals / Writing Sessions / Streak tracking (deferred)
- Writing Stats Dashboard (deferred)
- Consistency checking (M4)
- Advanced pacing visualizer (future)
- Multi-model support (Claude, GPT - future)
- Embeddings-based semantic search context (M4)
- Version comparison diff viewer (M4+)
- CLI `inxtone bible` commands (M4+)

## Deliverables

| # | Deliverable | Acceptance Criteria |
|---|-------------|---------------------|
| 1 | **WritingService Implementation** | Chapter/Volume CRUD, manual save, version + rollback, FK cleanup |
| 2 | **AIService Implementation** | Gemini 2.5 Pro streaming, ContextBuilder, prompt templates |
| 3 | **Chapter Editor** | `@uiw/react-md-editor` with manual save, word count |
| 4 | **AI Collaboration Panel** | Sidebar with context preview, streaming response, accept/reject |
| 5 | **Plot Outliner** | Arc → Chapter hierarchy view + Foreshadowing tracker |
| 6 | **Version History** | Auto-version before AI generation, manual version, rollback |

---

## Tasks

### Phase 1: Writing Service (Day 1-5)

- [ ] Implement `WritingRepository`
  - [ ] Chapter CRUD
  - [ ] Volume management
  - [ ] Version storage (create, list, get, rollback)
- [ ] Implement `WritingService`
  - [ ] Chapter operations (CRUD, reorder, filter by status/volume/arc)
  - [ ] `saveContent()` — manual save only (Ctrl+S / Save button)
  - [ ] Manual version creation
  - [ ] Auto-version before AI generation (ai_backup)
  - [ ] Rollback functionality (backup current → restore target)
  - [ ] `getWordCount()`, `getTotalWordCount()`
  - [ ] FK cleanup on entity deletion (删角色 → 章节自动移除该角色引用)
- [ ] Integrate with EventBus
  - [ ] CHAPTER_SAVED, CHAPTER_CREATED, CHAPTER_DELETED events
  - [ ] VERSION_CREATED events (with source: auto/manual/ai_backup/rollback_backup)
  - [ ] CHAPTER_STATUS_CHANGED events
- [ ] Write unit tests

### Phase 2: AI Service (Day 6-10)

- [ ] Implement `GeminiProvider`
  - [ ] `@google/genai` SDK integration (model: `gemini-2.5-pro`)
  - [ ] Streaming response via `generateContentStream()`
  - [ ] Rate limiting (respect API quotas)
  - [ ] Error handling (auth, rate limit, content filter, network)
- [ ] Implement `ContextBuilder` (核心大脑)
  - [ ] Layer 1 — Required: current chapter content + outline + prev chapter tail
  - [ ] Layer 2 — FK expansion: chapter.characters[] → full profiles (motivation, facets, voiceSamples)
  - [ ] Layer 2 — FK expansion: chapter.locations[] → descriptions
  - [ ] Layer 2 — FK expansion: chapter.arcId → Arc structure + progress
  - [ ] Layer 2 — FK expansion: character relationships (Scoped Relationship Rules, see below)
  - [ ] Layer 3 — Plot awareness: chapter.foreshadowingHinted[] → foreshadowing content
  - [ ] Layer 3 — Plot awareness: active foreshadowing in current Arc
  - [ ] Layer 3 — Plot awareness: prev chapter hook → continuity
  - [ ] Layer 4 — World rules: powerSystem.coreRules, socialRules
  - [ ] Layer 5 — User-selected additional context
  - [ ] Batch query optimization (批量查询角色/地点/伏笔，避免 N+1)
  - [ ] Token budget management (estimate → fill by priority → truncate)
- [ ] Implement `PromptAssembler`
  - [ ] Continuation prompt template
  - [ ] Dialogue generation prompt template
  - [ ] Scene description prompt template
  - [ ] Brainstorm prompt template
  - [ ] Template variable injection (context + instruction → final prompt)
- [ ] Create `/api/ai` endpoints
  - [ ] POST /api/ai/stream - streaming response (SSE)
  - [ ] POST /api/ai/build-context - preview assembled context
  - [ ] GET /api/ai/providers - available provider info

### Phase 3: Plot System API (Day 11-13)

> Note: Arc, Foreshadowing, Hook repositories and service methods already exist in M2's StoryBibleService.
> This phase focuses on exposing them via API endpoints and connecting to the writing workflow.

- [ ] Create `/api/arcs` endpoints (CRUD + progress)
- [ ] Create `/api/foreshadowing` endpoints (CRUD + addHint + resolve + abandon)
- [ ] Create `/api/hooks` endpoints (CRUD + strength tracking)
- [ ] Wire plot data into ContextBuilder
  - [ ] Auto-include foreshadowing hints for current chapter
  - [ ] Include arc progress in context
- [ ] Write API tests

### Phase 4: Chapter Editor UI (Day 14-17)

- [ ] **Editor Component**
  - [ ] `@uiw/react-md-editor` integration
  - [ ] Manual save (Ctrl+S / toolbar Save button)
  - [ ] Save indicator ("已保存" / "未保存 *")
  - [ ] Unsaved changes warning on navigation (切换章节/关闭页面前提示)
  - [ ] Word count display
- [ ] **Three-Panel Layout**
  - [ ] Left panel: Chapter list (filterable by Arc) + Story Bible quick-ref
  - [ ] Center: Editor
  - [ ] Right panel: AI Sidebar (collapsible)
- [ ] **AI Sidebar**
  - [ ] Context preview: show assembled context items (characters, locations, foreshadowing)
  - [ ] Context editing: toggle items on/off
  - [ ] Prompt input field
  - [ ] Quick action buttons (Continue, Dialogue, Describe, Brainstorm)
  - [ ] Button disable during AI generation (aiLoading state)
  - [ ] Streaming response display area (支持半截内容显示)
  - [ ] Accept → insert at cursor position
  - [ ] Reject → 必须填写拒绝理由 (modal/input)
  - [ ] Regenerate → 复用 context + 注入 reject reason
  - [ ] Brainstorm → Accept 后触发 Continue 流程
- [ ] **Story Bible Panel (Left)**
  - [ ] Current chapter's characters (quick view)
  - [ ] Current chapter's locations
  - [ ] Active foreshadowing for this chapter
  - [ ] "Add to AI context" toggle per item

### Phase 5: Plot UI (Day 18-19)

- [ ] **Arc Outliner**
  - [ ] Tree view: Arc → Sections → Chapters
  - [ ] Progress indicators (%, status badges)
  - [ ] Click to navigate to chapter
  - [ ] Status indicators (planned/in_progress/complete)
- [ ] **Foreshadowing Tracker**
  - [ ] Active foreshadowing list with status
  - [ ] Plant → Hint → Resolve lifecycle visualization
  - [ ] Add hint from current chapter action
  - [ ] Resolve/abandon actions
  - [ ] Overdue foreshadowing warnings
- [ ] **Hook Tracker**
  - [ ] Hooks by chapter
  - [ ] Strength indicator

### Phase 6: Testing & Polish (Day 20-21)

- [ ] End-to-end tests
  - [ ] Write chapter → AI continue → accept → save → verify content
  - [ ] Create version → modify → rollback → verify
  - [ ] Plot flow: create arc → assign chapters → track progress
- [ ] AI integration tests
  - [ ] Mock Gemini responses for deterministic testing
  - [ ] Test streaming (chunk-by-chunk delivery)
  - [ ] Test error handling (rate limit, auth, network)
  - [ ] Test ContextBuilder assembly accuracy
- [ ] Performance testing
  - [ ] Editor performance with large chapters (10K+ words)
  - [ ] Context building speed (target: <500ms)
- [ ] Bug fixes

---

## Test Plan

### Unit Tests
- [ ] WritingService: saveContent (manual), version creation, rollback, FK cleanup
- [ ] ContextBuilder: layer assembly, priority ordering, token budgeting
- [ ] PromptAssembler: template rendering with variables
- [ ] GeminiProvider: stream parsing, error handling

### Integration Tests
- [ ] WritingService + Repository (SQLite)
- [ ] ContextBuilder + StoryBibleService (FK expansion accuracy)
- [ ] AIService + Gemini API (mocked)
- [ ] API endpoints + Service layer

### E2E Tests
- [ ] Full writing flow: create chapter → edit → manual save → AI assist → accept → save
- [ ] Version history: manual save → AI generate (auto-backup) → rollback → verify
- [ ] FK cleanup: delete character → verify chapter references updated
- [ ] Plot management: create arc → add chapters → track foreshadowing → resolve

---

## Technical Notes

### ContextBuilder Architecture (核心大脑)

```
输入: chapterId + userInstruction
  │
  ▼
Layer 1 — Required (always included):
  ├─ chapter.content (last N paragraphs if too long)
  ├─ chapter.outline (goal, scenes, hookEnding)
  └─ prevChapter tail (last 500 chars)
  │
  ▼
Layer 2 — FK Expansion (批量查询, auto-detected from chapter metadata):
  ├─ chapter.characters[] → CharacterRepo.findByIds([...]) (批量)
  │   → name, appearance, motivation, facets, voiceSamples
  ├─ chapter.locations[] → LocationRepo.findByIds([...]) (批量)
  │   → name, type, significance, atmosphere
  ├─ chapter.arcId → ArcRepo.findById()
  │   → name, type, progress, sections, status
  └─ Scoped Relationships (仅本章角色间):
      → 规则: 只查询本章 characters[] 中角色之间的直接关系
      → A ↔ B 有直接关系 → 包含
      → A ↔ B 无直接关系，但 A→C→B → 包含间接路径
      → 不拉入不在本章的角色 C 的完整档案
  │
  ▼
Layer 3 — Plot Awareness (批量查询):
  ├─ chapter.foreshadowingHinted[] → ForeshadowingRepo.findByIds([...]) (批量)
  │   → content, plantedText, hints so far
  ├─ Active foreshadowing in current Arc (planted but unresolved)
  └─ prevChapter hooks → HookRepo.findByChapter(prevChapterId)
  │
  ▼
Layer 4 — World Rules:
  ├─ WorldRepo.get() → powerSystem.coreRules (always included)
  └─ socialRules (if relevant characters/factions involved)
  │
  ▼
Layer 5 — User-Selected:
  └─ Additional items user explicitly toggled in UI
  │
  ▼
Token Budget Management:
  budget = model.maxInputTokens - reserveForOutput(4000) - reserveForPrompt(2000)
  Fill layers 1-5 by priority, truncate from lowest priority if over budget
  │
  ▼
Output: Formatted context string + token stats + truncation report
```

**Key insight**: No semantic search needed for MVP. Chapter.characters[], Chapter.locations[],
Chapter.foreshadowingHinted[] etc. provide deterministic, author-intent-driven context assembly.
Semantic search (M4) will enhance this, not replace it.

### AI Interaction Model: Sidebar Preview + Accept

```
User clicks action button in AI sidebar
  │ (生成中: 所有操作按钮禁用，直到完成)
  ▼
ContextBuilder assembles context from chapter FK metadata
  │
  ▼
PromptAssembler injects context + user instruction into template
  │
  ▼
GeminiProvider streams response via SSE
  │
  ▼
AI Sidebar shows streaming text in preview area
  │ (流中断 → 保留已收到的部分内容，用户可 accept 半截)
  ▼
User reviews and chooses:
  ├─ [Accept] → content inserted at editor cursor position (光标处)
  ├─ [Reject] → 必须填写拒绝理由 → content discarded
  └─ [Regenerate] → see Regenerate Logic below
```

### Generation Types (四种生成模式)

```
┌─────────────┬──────────────────────────────────────────────┐
│ 类型         │ 行为                                         │
├─────────────┼──────────────────────────────────────────────┤
│ Continue    │ 续写: 根据方法论生成接下来的完整内容          │
│ (续写)      │ 这是核心功能，输出直接可用于正文              │
│             │ Accept → 插入到光标位置                       │
├─────────────┼──────────────────────────────────────────────┤
│ Dialogue    │ 对话: 只生成一段对话                          │
│ (对话)      │ 专注于角色间的对话交互                        │
│             │ Accept → 插入到光标位置                       │
├─────────────┼──────────────────────────────────────────────┤
│ Describe    │ 描写: 只生成一段描写                          │
│ (描写)      │ 场景描写、人物描写、动作描写等                │
│             │ Accept → 插入到光标位置                       │
├─────────────┼──────────────────────────────────────────────┤
│ Brainstorm  │ 头脑风暴: 给用户一个续写概念/方向             │
│ (头脑风暴)  │ 用户还不确定接下来写什么                      │
│             │ 输出是概念预览，不直接用于正文                 │
│             │ 满意 → 基于此概念执行 Continue 续写            │
│             │ 不满意 → Reject + 理由 → Regenerate           │
└─────────────┴──────────────────────────────────────────────┘
```

### Reject + Regenerate Flow

```
用户点击 [Reject]:
  │
  ▼
弹出输入框: "为什么不满意？" (必填)
  │ 例: "语气太正式" / "不要写打斗" / "应该更搞笑"
  ▼
保存: { rejectedContent, rejectReason, generationType }
  │
  ▼
用户点击 [Regenerate]:
  │
  ▼
Regenerate 逻辑:
  ├─ 默认: 复用当前 context (不重新 build，省 token)
  │
  ├─ Prompt 注入:
  │   "上次生成的内容被拒绝。
  │    拒绝原因: {{rejectReason}}
  │    被拒绝的内容: {{rejectedContent}}
  │    请避免相同问题，重新生成。"
  │
  └─ AI 自行判断是否需要更多 context:
      如果拒绝理由涉及引入新角色/新地点 → AI 可请求补充 context
      如果只是语气/表达/风格调整 → 复用当前 context 即可

注意: Brainstorm → Accept 后的 Continue 也复用 brainstorm 的 context
```

### Streaming Error Handling

```
SSE 流中断时 (网络抖动/API 超时):
  │
  ▼
已收到部分内容?
  ├─ 是 → 保留部分内容，显示 "生成中断" 提示
  │       用户可以:
  │       ├─ [Accept] 接受半截内容 (插入到光标)
  │       ├─ [Reject] 放弃
  │       └─ [Retry] 重新生成 (全新请求)
  │
  └─ 否 → 显示错误提示 + [Retry] 按钮
```

### UI Button States During AI Generation

```
生成中 (aiLoading = true):
  ├─ Continue / Dialogue / Describe / Brainstorm → 全部禁用
  ├─ Accept / Reject → 禁用 (等生成完成)
  ├─ Save (Ctrl+S) → 仍然可用
  └─ 编辑器 → 仍然可用 (用户可以边等边改)

生成完成 (aiLoading = false):
  ├─ Accept / Reject / Regenerate → 启用
  └─ 新的 AI 操作 → 启用
```

### AI Provider Configuration

```typescript
// MVP: Gemini 2.5 Pro only, no fallback chain
const AI_CONFIG = {
  provider: 'gemini',
  model: 'gemini-2.5-pro',
  sdk: '@google/genai',      // New official SDK (replaces @google/generative-ai)
  maxInputTokens: 1_000_000, // 1M context window
  defaultTemperature: 0.7,
  maxOutputTokens: 4000,
};
```

### Streaming Response

```typescript
// Server-Sent Events for AI streaming
// POST /api/ai/stream

// Client receives:
event: chunk
data: {"text": "The door creaked open..."}

event: chunk
data: {"text": " revealing a figure in shadow."}

event: complete
data: {"totalTokens": 150, "finishReason": "stop"}

event: error
data: {"error": "Rate limit exceeded", "retriable": true}
```

### Editor State

```typescript
interface EditorState {
  chapterId: ChapterId;
  content: string;
  isDirty: boolean;
  lastSaved: Date | null;
  wordCount: number;
  cursorPosition: number;          // 光标位置 (Accept 时插入到这里)
  // AI
  aiPanelOpen: boolean;
  aiLoading: boolean;              // true → 禁用所有 AI 按钮
  aiResponse: AIResponse | null;   // 当前生成结果 (单个)
  aiHistory: AIHistoryEntry[];     // Reject 历史 (用于 regenerate)
  contextPreview: ContextItem[];   // What AI "knows" for this chapter
  builtContext: BuiltContext | null; // 缓存的 context (regenerate 复用)
}

type GenerationType = 'continue' | 'dialogue' | 'describe' | 'brainstorm';

interface AIResponse {
  id: string;
  content: string;               // 生成的内容 (可能是半截)
  generationType: GenerationType;
  isPartial: boolean;            // 流中断时 = true
  tokenUsage?: { input: number; output: number };
}

interface AIHistoryEntry {
  rejectedContent: string;
  rejectReason: string;          // 必填
  generationType: GenerationType;
}
```

### Editor Component

```typescript
// @uiw/react-md-editor — lightweight (~4.6kB gzip)
// Built-in: Markdown syntax highlighting, live preview, auto-indent
// Manual save: Ctrl+S or Save button

import MDEditor from '@uiw/react-md-editor';

<MDEditor
  value={content}
  onChange={handleChange}  // string → update local state → mark isDirty
  height={600}
/>
// Ctrl+S → saveContent() → clear isDirty
```

---

## Dependencies

- M2 must be complete (Story Bible service + repositories for context)
- Gemini API key required (BYOK)
- `@google/genai` npm package
- `@uiw/react-md-editor` npm package

## Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Gemini API rate limits | Medium | Medium | Rate limiting in GeminiProvider, user feedback |
| Editor performance with large chapters | Medium | High | Lazy rendering, manual save |
| Context too large for token budget | High | Medium | Priority-based truncation, token counting |
| Streaming SSE complexity | Medium | Medium | Robust error handling, reconnect logic |
| ContextBuilder latency (many FK lookups) | Low | Medium | 批量查询 (findByIds), avoid N+1 |

---

## Notes

- **核心价值**: AI 协作写作是 Inxtone 的核心体验，但真正的差异化在于 Context Builder —— AI 知道你的故事结构
- **ContextBuilder 是引擎的大脑**: 基于 Chapter 实体的外键做确定性 context 组装，不依赖 semantic search
- **Plot UI 是核心价值感体现**: Arc Outliner + Foreshadowing Tracker 给作者"系统帮我记着"的安全感
- **编辑器选择**: `@uiw/react-md-editor` (最轻量，5分钟集成，后期可换 CodeMirror 6)
- **AI 交互模式**: Sidebar Preview + Accept (用户掌控感 > 行内流式)
- **MVP 只支持 Gemini 2.5 Pro**: 单 provider，无 fallback，M4+ 再加其他模型
- **Manual Save**: 不做 auto-save，用 Ctrl+S 手动保存，简化状态管理
- **Writing Goals / Stats 已推迟**: 非核心展示功能，不在 M3 范围内

### Scoped Relationship Rules (角色关系作用域)

```
本章 characters[] = [A, B, D]

查询逻辑:
1. 查所有涉及本章角色的 relationships
2. 过滤规则:
   ├─ A ↔ B (直接关系) → ✅ 包含
   ├─ A ↔ D (直接关系) → ✅ 包含
   ├─ B ↔ D (直接关系) → ✅ 包含
   ├─ A ↔ C (C 不在本章) → ❌ 不包含
   └─ 例外: A 和 D 之间无直接关系，
           但 A → C → D 存在间接路径 → ✅ 包含路径描述
           (不拉入 C 的完整档案，只描述关系链)

实现:
  const chapterCharIds = new Set(chapter.characters)
  // Step 1: 批量查所有相关 relationships
  const allRels = RelationshipRepo.findByCharacters(chapter.characters)
  // Step 2: 过滤直接关系 (both sides in chapter)
  const directRels = allRels.filter(r =>
    chapterCharIds.has(r.character1Id) && chapterCharIds.has(r.character2Id)
  )
  // Step 3: 检查无直接关系的角色对，寻找间接路径
  // (仅一跳: A→C→B, C 为中间人)
```

### FK Cleanup on Entity Deletion (实体删除时清理章节引用)

```
角色被删除时:
  1. 事务中执行:
     a. 查找所有 chapters where characters[] contains characterId
     b. 从这些 chapters 的 characters[] 中移除该 characterId
     c. 删除 character 本身
  2. 同理适用于: locations[], foreshadowingPlanted[], foreshadowingHinted[]

目的: 避免悬空引用 (dangling FK references)
实现层: Service 层 (db.transaction 包装)
```

### Batch Query Strategy (批量查询策略)

```
ContextBuilder.build(chapterId) 内部:
  ❌ 错误: N+1 查询
     for (const charId of chapter.characters) {
       const char = CharacterRepo.findById(charId)  // N 次查询
     }

  ✅ 正确: 批量查询
     const chars = CharacterRepo.findByIds(chapter.characters)  // 1 次查询
     const locs = LocationRepo.findByIds(chapter.locations)      // 1 次查询
     const foreshadowings = ForeshadowingRepo.findByIds(chapter.foreshadowingHinted) // 1 次查询
     const rels = RelationshipRepo.findByCharacters(chapter.characters) // 1 次查询

  总查询数: ~5-7 次 (固定), 不随角色/地点数量增长
```
